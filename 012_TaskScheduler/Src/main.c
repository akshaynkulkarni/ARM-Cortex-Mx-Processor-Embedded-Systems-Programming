/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "task.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

extern void initialise_monitor_handles();
extern void init_all_fault_handlers();
extern void enable_exception_zerodivide();
extern void sw_delay(uint32_t t_ms);

extern void SysClkTicker_Init();
extern void tasks_start();

extern uint32_t initial_psp;
extern uint32_t global_ticks;

#define BASE_DELAY (1000) // 100ms

#define TASK_PRINT 1

void stack_init()
{
	// we will keep MSP untouched
	__asm volatile("MSR PSP, %[PSP_init]" ::[PSP_init] "r"(initial_psp));
}

extern void switch_sp_to_psp();

void IDLE_TASK(void *x, void *y) // IDLE task
{
	//	int ret = system_init();

	/* Loop forever */
	for (;;)
		;
}

void task0(void *param1, void *param2);
void task1(void *param1, void *param2);
void task2(void *param1, void *param2);
void task3(void *param1, void *param2);

void create_tasks()
{
	printf("Init user tasks..\n");
	task_create(&task0); // task 0
	task_create(&task1); // task 1
#if (USER_TASK_MAX_NO - 1) > 2
	task_create(&task2); // task 2
#endif
#if (USER_TASK_MAX_NO - 1) > 3
	task_create(&task3); // task 3
#endif
	task_create(&IDLE_TASK);
}
void start_tasks()
{

	printf("Starting User Tasks..\n");
	tasks_start();
}

int main()
{
	stack_init();

	initialise_monitor_handles();

	init_all_fault_handlers();

	enable_exception_zerodivide();

	SysClkTicker_Init(1000U); // To get 1ms -> 1000HZ

	create_tasks();

	start_tasks();

	return 0;
}

void task(void *param1, void *param2)
{
	uint32_t taskno = *((uint32_t *)&param1);
	uint32_t delay_ms = *((uint32_t *)&param2);

	for (;;)
	{
		// printf("T%lu\n", taskno);
		delay(delay_ms);
	}
}

void task0(void *param1, void *param2)
{
	uint32_t taskno = 0;
	uint32_t delay_ms = (0.5) * BASE_DELAY;

	for (;;)
	{
#ifdef TASK_PRINT
		printf("T%lu@%ld ", taskno, global_ticks);
#endif
		delay(delay_ms);
	}
}

void task1(void *param1, void *param2)
{
	uint32_t taskno = 1;
	uint32_t delay_ms = BASE_DELAY * taskno;

	for (;;)
	{
#ifdef TASK_PRINT
		printf("T%lu@%ld ", taskno, global_ticks);
#endif
		delay(delay_ms);
	}
}

void task2(void *param1, void *param2)
{
	uint32_t taskno = 2;
	uint32_t delay_ms = BASE_DELAY * taskno;

	for (;;)
	{
#ifdef TASK_PRINT
		printf("T%lu@%ld ", taskno, global_ticks);
#endif
		delay(delay_ms);
	}
}

void task3(void *param1, void *param2)
{
	uint32_t taskno = 3;
	uint32_t delay_ms = BASE_DELAY * taskno;

	for (;;)
	{
#ifdef TASK_PRINT
		printf("T%lu@%ld ", taskno, global_ticks);
#endif
		delay(delay_ms);
	}
}
