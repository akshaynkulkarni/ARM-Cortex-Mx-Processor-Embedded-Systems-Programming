/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* This function executes in THREAD MODE of the processor */
#define NVIC_STIR 				(0xE000EF00U)
#define NVIC_ISER1	 			(0xE000E100U + 4U)

void generate_interrupt()
{

	// the below are priv instructions.
	// if executed in un priv mode, fault error occurs

	// enable IRQ3 interrupt
	*((uint32_t *)NVIC_ISER1)  |= (1 << 18);

	// generate an interrupt from software for IRQ50
	*((uint32_t *)NVIC_STIR) = (0x1FF & 50);
}

void go_unpriv_mode()
{
	// set CONTROL[0] = 1, unpriv mode
	__asm volatile("MRS R0, CONTROL");
	__asm volatile("ORR R0, R0, #0x01");
	__asm volatile("MSR CONTROL, R0");
}

void go_priv_mode()
{
	// set CONTROL[0] = 0, priv mode
	__asm volatile("MRS R0, CONTROL");
	__asm volatile("AND R0, R0, #0xFFFFFFFE");
	__asm volatile("MSR CONTROL, R0");
}


/* This function executes in THREAD MODE of the processor */
extern void initialise_monitor_handles();

int main(void)
{

	initialise_monitor_handles();

	printf("In thread mode : before interrupt\n");

	generate_interrupt();

	void (*fun_ptr)(void); // function pointer

	/*
	 * The below commented code will result in invalid state,
	 * ideally would result to usage fault.
	 *
	 * But, here in this code, the usage fault handler is not implemented,
	 * hence Hard fault ISR is hit!
	 */

	// fun_ptr = 0x8000290// <generate_interrupt>; // lead to invalid state without 0x8000290 | 1U;

	fun_ptr = generate_interrupt;

	// fun_ptr();

	// the compiler makes the addresses to be odd in order to maintain T bit.
	// The T bit is linked to LSB bit of PC, which is expected to be 1 always, as Cortex Mx supports only thumb2 mode.
	// But when we check the disassembly, the address of go_unpriv_mode() is even.
	printf("fun_ptr = 0x%lX and addr of generate_interrupt = 0x%lX\n", (uint32_t)fun_ptr, (uint32_t)generate_interrupt);
	 go_unpriv_mode();
	printf("In thread mode : after interrupt\n");

	for (;;)
		;
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void TIM5_IRQHandler(void)
{
	printf("In TIM5_IRQHandler: ISR\n");
}

void HardFault_Handler()
{
	printf("Hard fault occurred\n");
	for (;;)
		;
}
