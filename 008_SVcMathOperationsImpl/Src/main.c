/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

__attribute__((naked)) void SVC_Handler(void)
{
	__asm volatile("MRS R0, MSP");
	__asm volatile("B SVC_Handler_c");
}

void SVC_Handler_c(uint32_t *pStackBase)
{
	uint32_t prev_pc = (uint32_t)pStackBase[6];

	uint8_t *svc_num = (uint8_t *)(prev_pc - 2);

	switch (*svc_num)
	{
	case 1: // Addition
		pStackBase[0] = pStackBase[0] + pStackBase[1];
		break;
	case 2: // SUb
		pStackBase[0] = pStackBase[0] - pStackBase[1];
		break;
	case 3: // Mul
		uint64_t result = pStackBase[0] * pStackBase[1];
		;
		pStackBase[0] = result & 0xFFFF;
		pStackBase[1] = result & 0xFFFF0000;
		break;
	case 4: // div
		if (pStackBase[1])
			pStackBase[0] = pStackBase[0] / pStackBase[1];
		else
			pStackBase[0] = 0;
		break;
	default:
		pStackBase[0] = 0;
	}
}

uint32_t svc_call_add(uint32_t a, uint32_t b)
{
	uint32_t ret_val = 0;
	//__asm volatile("MOV R0, %[a_asm]" : : [a_asm] "r" (a)); // Note 1
	//__asm volatile("MOV R1, %[b_asm]" : : [b_asm] "r" (b)); // Note 1
	__asm volatile("SVC #1"); // note 2
	__asm volatile("MOV %[out], R0" : [out] "=r"(ret_val));
	return ret_val;
}

uint32_t svc_call_sub(uint32_t a, uint32_t b)
{
	uint32_t ret_val = 0;
	//__asm volatile("MOV R0, %[a_asm]" : : [a_asm] "r" (a)); // Note 1
	//__asm volatile("MOV R1, %[b_asm]" : : [b_asm] "r" (b)); // Note 1
	__asm volatile("SVC #2"); // note 2
	__asm volatile("MOV %[out], R0" : [out] "=r"(ret_val));
	return ret_val;
}

uint64_t svc_call_mul(uint32_t a, uint32_t b)
{
	uint64_t ret_val = 0;
	//__asm volatile("MOV R0, %[a_asm]" : : [a_asm] "r" (a)); // Note 1
	//__asm volatile("MOV R1, %[b_asm]" : : [b_asm] "r" (b)); // Note 1
	__asm volatile("SVC #3"); // note 2
	uint64_t *pret_val = &ret_val;
	__asm volatile("MOV R3, %[ret_val_asm]" ::[ret_val_asm] "r"(pret_val));
	__asm volatile("STR R0, [R3]");
	__asm volatile("STR R1, [R3, #4]");

	//__asm volatile("MOV %[out], R1": [out] "=r" (ret_val));
	return ret_val;
}

uint32_t svc_call_div(uint32_t a, uint32_t b)
{
	uint32_t ret_val = 0;
	//__asm volatile("MOV R0, %[a_asm]" : : [a_asm] "r" (a)); // Note 1
	//__asm volatile("MOV R1, %[b_asm]" : : [b_asm] "r" (b)); // Note 1
	__asm volatile("SVC #4"); // note 2
	__asm volatile("MOV %[out], R0" : [out] "=r"(ret_val));
	return ret_val;
}

/*
 * Note 1: Ideally these instr. are not required, as the function is not naked.
 * 		   This means, compiler takes care of AAPCS standards,
 * 		   i.e. R0, R1 are seen as args here.
 * Note 2:  At this point of time, the context is saved on the stack i.e. R0, R1 args.
 * 			Hence, in the SVC ISR, we can use the stack to get the arguments.
 */

int main(void)
{

	printf("SVC add = %lu\n", svc_call_add(55, 5));
	printf("SVC sub = %lu\n", svc_call_sub(55, 5));
	printf("SVC mul = %lu\n", (uint32_t)svc_call_mul(55, 5)); // seems like llu is not implemented
	printf("SVC div = %lu\n", svc_call_div(55, 5));

	/* Loop forever */
	for (;;)
		;
}
