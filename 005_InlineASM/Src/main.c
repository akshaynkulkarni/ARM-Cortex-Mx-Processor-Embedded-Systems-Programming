/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{

	initialise_monitor_handles();
	// do z = x + y inline ASM

	volatile int x = 5;
	volatile int y = 3;
	volatile int res = 0;

	/*
	 * __asm volatile("ASM CODE" : Output operands : input operands : clobber list);
	 * input/ output operands => constraints + C expressions
	 * constraints = constr. char + constr modifier. Check: http://www.ethernut.de/en/documents/arm-inline-asm.html#:~:text=the%20next%20topic.-,Input%20and%20output%20operands,-We%20learned%2C%20that
	 *
	 *
	 */
#if 0
	__asm volatile ("MOV R0, %0": : "r" (x));
	__asm volatile ("MOV R1, %0": : "r" (y));
	__asm volatile ("ADD R2, R0, R1":::);
	__asm volatile ("MOV %0, R2" : "=r"(res) );
#endif

#if 0
	__asm volatile ("MOV R0, %1\t\n"
					"MOV R1, %2\t\n"
					"ADD R2, R0, R1\t\n"
					"MOV %0, R2":
					"=r"(res): "r"(x), "r"(y):);
#endif

	__asm volatile("MOV R0, %[x_asm] \t\n"
				   "MOV R1, %[y_asm] \t\n"
				   "ADD R2, R0, R1 \t\n"
				   "MOV %[res_asm], R2" :
				   [res_asm] "=r"(res) :
				   [x_asm] "r"(x), [y_asm] "r"(y)
				   :);
	int a = 10, b;
	// b = a;

	__asm volatile("MOV %0, %1" : "=r"(b) : "r"(a));

	int p1, *ptr2;

	ptr2 = &a;

	// copy contents pointed by ptr2 to p1

	__asm volatile("LDR %0, [%1]" : "=r"(p1) : "r"(ptr2));

	uint32_t control_reg;

	__asm volatile("MRS %[ctrl_reg_asm], CONTROL" : [ctrl_reg_asm] "=r"(control_reg));

	printf("CONTROL REG = 0x%lX\n", control_reg);

	/* Loop forever */
	while (1)
	{
		printf("Addition of x & y = %d\n", res);
	}
}
