/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define NVIC_ISER0			(0xE000E100U) // Interrupt Set-enable Registers
#define NVIC_ICER0			(0XE000E180U) // Interrupt Clear-enable Registers
#define NVIC_ISPR_BASE		(0XE000E200U) // Interrupt Set-pending Registers

#define NVIC_IABR0			(0xE000E300U) // Interrupt Active Bit Registers

#define NVIC_IPR_BASE		(0xE000E400U) // Interrupt Priority Registers
#define NVIC_IPR_REG(X)		(NVIC_IPR_BASE +  (4 * (X/4))) // Interrupt Priority Registers
#define NVIC_IPR_REG_BIT_OFFSET(X)	(8 * (X % 4))


#define SCB_AIRCR			(0xE000ED0CU) // Application Interrupt and Reset Control Register
#define VECTKEY				(0x5FA << 16)

#define IRQ11_DMA1			(11U)
#define IRQ18_ADC			(18U)

/* Continuation from 003_InterruptDemo...
 *
 * In this exercise, we configure interrupt priority for two ISRs,
 *  with same and different prio. and observe the behavior.
 *  1. ISQ 11: DMA1_Stream0 (DMA1 Stream0 global interrupt)
 *  2. IRQ 18: ADC (ADC1 global interrupts)
 */

uint8_t pend_in_irq = 0; // No pending in IRQ

void config_priority_group(uint8_t priority_group)
{

	uint32_t *pSCB_AIRCR = (uint32_t *)SCB_AIRCR;

	uint32_t AIRCR_temp = *pSCB_AIRCR;
	// VECTKEY and PRIGROUP must be cleared
	AIRCR_temp &= ~((0xFFFF << 16) | (0x7 << 8));
	// write back with VECTKEY for actual reg. write and PRIGROUP.
	*pSCB_AIRCR = AIRCR_temp | VECTKEY | (priority_group & 0x7) << 8;

	return;
}

void config_IRQx_priority(uint8_t irqno, uint8_t priority)
{

	uint32_t *pPriorityIRQx = (uint32_t *)NVIC_IPR_REG(irqno);
	// clear the priority
	*pPriorityIRQx &= ~(0xFF << (NVIC_IPR_REG_BIT_OFFSET(irqno)));
	// set the priority
	*pPriorityIRQx |= (priority << (NVIC_IPR_REG_BIT_OFFSET(irqno)));

	return;
}

void config_IRQx_pend(uint8_t irqno)
{

	uint8_t regno = irqno / 32;
	uint8_t offset = irqno % 32;

	uint32_t *pNVIC_ISPRx = (uint32_t *)(NVIC_ISPR_BASE + regno);

	*pNVIC_ISPRx |= (1 << offset);

	return;
}

void config_IRQx_pend_multi(uint8_t irqno[], uint8_t no)
{

	for (uint8_t i = 0; i < no; ++i)
	{
		uint8_t regno = irqno[i] / 32;
		uint8_t offset = irqno[i] % 32;

		uint32_t *pNVIC_ISPRx = (uint32_t *)(NVIC_ISPR_BASE + regno);

		*pNVIC_ISPRx |= (1 << offset);
	}

	return;
}

void config_IRQx_enable(uint8_t irqno)
{

	uint32_t *pNVIC_ISER0 = (uint32_t *)NVIC_ISER0;

	*pNVIC_ISER0 |= (1 << irqno);

	return;
}

void config_IRQx_disable(uint8_t irqno)
{

	uint32_t *pNVIC_ICER0 = (uint32_t *)NVIC_ICER0;

	*pNVIC_ICER0 |= (1 << irqno);

	return;
}

void reset_irqs()
{
	config_IRQx_disable(IRQ11_DMA1);
	config_IRQx_disable(IRQ18_ADC);
}

/* Important points from:
 * https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/interrupt-priority-grouping?lang=en
 *
 * 1.  Only the group priority determines preemption of interrupt exceptions, i.e.,
 * 	   the sub priority doesn't lead to preemption rather influence the order of
 *     processing of pending IRQs.
 *
 * 2. If multiple pending interrupts have the same group priority,
 *    the subpriority field determines the order in which they are processed.
 *
 * 3. If multiple pending interrupts have the same group priority and subpriority,
 * 	  the interrupt with the lowest IRQ number is processed first.
 */

int8_t prioDMA = 0x10;
int8_t prioADC = 0x10;

/*
 * Case 1:
 * 	IRQ DMA has higher priority than IRQ ADC,
 * 	IRQ ADC is pended first.
 * 	IRQ DMA is pended in IRQ ADC, leading to nested interrupt.
 */
void exec_case1()
{
	pend_in_irq = 1;

	// Set the priority group to 5
	uint8_t priority_group = 5; // 0b101

	config_priority_group(priority_group);

	prioDMA = 0xA0; // 0b1010 00000
	prioADC = 0xC0; // 0b1100 00000

	config_IRQx_priority(IRQ11_DMA1, prioDMA); // HP
	config_IRQx_priority(IRQ18_ADC, prioADC);  // LP

	config_IRQx_pend(IRQ18_ADC);

	config_IRQx_enable(IRQ11_DMA1);
	config_IRQx_enable(IRQ18_ADC);

	pend_in_irq = 0;
}

/*
 * Case 2: Priority group 5 is chosen.
 * 		   Both have same preempt priority, but sub priority
 */

void exec_case2()
{
	pend_in_irq = 0;

	// Set the priority group to 5
	uint8_t priority_group = 5; // 0b101

	config_priority_group(priority_group);

	prioDMA = 0x01; // 0b0000 0000
	prioADC = 0x00; // 0b0001 0000

	config_IRQx_priority(IRQ11_DMA1, prioDMA); // LP
	config_IRQx_priority(IRQ18_ADC, prioADC);  // HP

	// pend both ISRs
	config_IRQx_pend(IRQ11_DMA1);
	config_IRQx_pend(IRQ18_ADC);

	config_IRQx_enable(IRQ11_DMA1);
	config_IRQx_enable(IRQ18_ADC);
	printf("post enable:\n");

	uint32_t *pNVIC_ISPRx = (uint32_t *)(NVIC_ISPR_BASE);

	// When both IRQs are pended at the same time,
	// Here, the ADC always gets the priority in order of execution
	*pNVIC_ISPRx |= (1 << IRQ18_ADC) | (1 << IRQ11_DMA1); // ADC goes first
	*pNVIC_ISPRx |= (1 << IRQ18_ADC);
	*pNVIC_ISPRx |= (1 << IRQ18_ADC) | (1 << IRQ11_DMA1); // Again ADC goes first

	pend_in_irq = 0;
}

/*
 * Case 3: Priority group 5 is chosen.
 * 		   Both have same priority for preempt and sub priority.
 * 		   Here, the one with lower IRQ number is processed first (DMA)
 */

void exec_case3()
{
	pend_in_irq = 0;

	// Set the priority group to 5
	uint8_t priority_group = 5; // 0b101

	config_priority_group(priority_group);

	prioDMA = 0x00;
	prioADC = 0x00;

	config_IRQx_priority(IRQ11_DMA1, prioDMA); // EP
	config_IRQx_priority(IRQ18_ADC, prioADC);  // EP

	// pend both ISRs
	config_IRQx_pend(IRQ11_DMA1);
	config_IRQx_pend(IRQ18_ADC);

	config_IRQx_enable(IRQ11_DMA1);
	config_IRQx_enable(IRQ18_ADC);

	printf("post enable:\n");

	uint32_t *pNVIC_ISPRx = (uint32_t *)(NVIC_ISPR_BASE);
	// When both IRQs are pended at the same time,
	// Here, the DMA IRQ always gets the priority in order of execution
	*pNVIC_ISPRx |= (1 << IRQ18_ADC) | (1 << IRQ11_DMA1); // DMA goes first, as DMA IRQ = 11, other is 18
	*pNVIC_ISPRx |= (1 << IRQ18_ADC);
	*pNVIC_ISPRx |= (1 << IRQ18_ADC) | (1 << IRQ11_DMA1); // Again DMA goes first
	pend_in_irq = 0;
}

extern void initialise_monitor_handles();

int main(void)
{

	initialise_monitor_handles();
	printf("################ Case 1 ################\n");
	exec_case1();
	reset_irqs();
	printf("################ Case 2 ################\n");
	exec_case2();
	reset_irqs();
	printf("################ Case 3 ################\n");
	exec_case3();
	/* Loop forever */
	for (;;)
		;
}
