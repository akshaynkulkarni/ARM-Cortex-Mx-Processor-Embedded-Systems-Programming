/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * ARM Cortex-M(x) processor operates in
 * 1. Thread mode: user/kernel running in un/privileged mode.
 * 2. Handler mode: System exception, external interrupt - privileged mode
 * The Special register "CONTROL" holds the status for Thread mode privilege level: CONTROL[0]"
 * The (I)PSR holds the interrupt number being processed. If 0, non handler mode.
 */

/* This function executes in THREAD MODE of the processor */
#define NVIC_STIR 				(0xE000EF00U)
#define NVIC_ISER1	 			(0xE000E100U + 4U)

void generate_interrupt()
{

	// the below are priv instructions.
	// if executed in un priv mode, fault error occurs

	// enable IRQ3 interrupt
	*((uint32_t *)NVIC_ISER1)  |= (1 << 18);

	// generate an interrupt from software for IRQ50
	*((uint32_t *)NVIC_STIR) = (0x1FF & 50);
}

void go_unpriv_mode()
{
	// set CONTROL[0] = 1, unpriv mode
	__asm volatile("MRS R0, CONTROL");
	__asm volatile("ORR R0, R0, #0x01");
	__asm volatile("MSR CONTROL, R0");
}

void go_priv_mode()
{
	// set CONTROL[0] = 0, priv mode
	__asm volatile("MRS R0, CONTROL");
	__asm volatile("AND R0, R0, #0xFFFFFFFE");
	__asm volatile("MSR CONTROL, R0");
}

int8_t is_handler_mode(void)
{
	uint32_t IPSR;

	__asm volatile("MRS %[PSR_VAR_ASM], PSR" : [PSR_VAR_ASM] "=r"(IPSR));

	if ((IPSR & 0x1F))
	{ // ISR_NUMBER, IRQ
		return 0;
	}
	else
	{
		uint32_t ControlReg;
		__asm volatile("MRS %[CTRL_VAR_ASM], CONTROL" : [CTRL_VAR_ASM] "=r"(ControlReg));

		if (!(ControlReg & 0x1)) // CONTROL[0] = 0, is priv.
			return 1;
		else
			return -1;
	}
}

extern void initialise_monitor_handles();
/* This function executes in THREAD MODE of the processor */
int main(void)
{

	initialise_monitor_handles();

	printf("In thread mode : before interrupt %d\n", is_handler_mode());

	generate_interrupt();

	go_unpriv_mode();

	//generate_interrupt(); // will cause fault !

	// must give -1, thread unpriv mode
	printf("In thread mode : after interrupt %d\n",  is_handler_mode());

	for (;;)
		;
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void TIM5_IRQHandler(void)
{
	printf("In TIM5_IRQHandler: ISR: %d\n", is_handler_mode());
}

void HardFault_Handler()
{
	printf("Hard fault occurred: %d\n", is_handler_mode());
	for (;;)
		;
}
