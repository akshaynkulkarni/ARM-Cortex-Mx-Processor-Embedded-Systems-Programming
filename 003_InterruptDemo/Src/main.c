/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * For external interrupt, the relevant registers in the NVIC are:
 * 1. Priority reg:	configure priority (optional)
 * 2. Enable reg:		To enable/disable the respective interrupt
 * 3. Pend reg:		if interrupt occurs, pending status (can be pended manually as well, example PendSV)
 * 4. Active reg:		Active status, if ISR is being serviced
 */

/*
 * In this exercise, for STM32F401RE, we shall enable and trigger IRQ 56
 * and define handler for DMA2_Stream0.
 *
 * For system exceptions, we have SCB/ICSR etc
 * For external interrupt,  we have registers:
 * 1. ISER : Interrupt Set Enable Register
 * 2. ISPR: Interrupt Set Pending Register (This is automatically set by hardware on interrupt)
 *
 * The NVIC delegates the interrupt to the CPU core, if ISER and ISPR are active for given IRQ.
 * Once the CPU core services the IRQ routine, the ISPR is cleared.
 *
 * 3. ICER : To clear the enable status for IRQ
 * 4. ICPR : To clear the pending status for IRQ
 * Pending status-> Servicing of IRQ is pending (1)
 *
 * 5. Priority register shall be seen in different exercise (Nested)
 */

#define ISER_BASE 				(0xE000E100U)
#define ISER_REG(X) 			(ISER_BASE + (4 * X))
#define ISPR_BASE 				(0XE000E200U)
#define ISPR_REG(X) 			(ISPR_BASE + (4 * X))

#define IRQ_BIT(IRQ_NUM) 		(IRQ_NUM % 32)

#define IRQ_DMA2_Stream0 		(56U)

#define IRQ_USART1 				(37U)

extern void initialise_monitor_handles();

int main(void)
{

	initialise_monitor_handles();

	volatile uint32_t *ispr_reg1 = (uint32_t *)(ISPR_REG(1)); // only for demo !!

	*ispr_reg1 |= 1 << IRQ_BIT(IRQ_DMA2_Stream0);
	*ispr_reg1 |= 1 << IRQ_BIT(IRQ_USART1);

	/* for IRQ56, enable the IRQ in ISER.
	 * then, pend the bit in pending register
	 *
	 */
	volatile uint32_t *iser_reg1 = (uint32_t *)(ISER_REG(1));

	*iser_reg1 |= (1 << IRQ_BIT(IRQ_DMA2_Stream0));
	*iser_reg1 |= (1 << IRQ_BIT(IRQ_USART1));
	/* Loop forever */
	for (;;)
	{
		printf("Hello, main....\n");
	}
}

void HardFault_Handler(void)
{
	printf("Hello, HardFault_Handler\n");
	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
}

void DMA2_Stream0_IRQHandler(void)
{
	printf("Hello, DMA2_Stream0_IRQHandler\n");

	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
}

void USART1_IRQHandler(void)
{
	printf("Hello, USART1_IRQHandler\n");
	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
	asm volatile("MOV R0, R0");
}
